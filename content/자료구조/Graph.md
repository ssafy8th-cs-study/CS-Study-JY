# Graph

</br>

## 그래프(Graph)

### 그래프란
그래프는 비선형적 자료구조 일종으로, 데이터를 담는 정점과 정점들을 연결하는 간선의 집합으로 구성되며 객체(정점) 간의 관계를 표현할 수 있는 자료구조.

![그래프](./img/[자료구조]graph_img.png)

### 그래프의 개념
- 단순히 노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료 구조
- 즉, 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조이다.
- Ex) 지도, 지하철 노선도의 최단 경로, 전기 회로의 소자들, 도로(교차점과 일방 통행길), 선수 과목 등
- 그래프는 여러 개의 고립된 부분 그래프(Isolated Subgraphs)로 구성될 수 있다.

### 그래프(Graph)의 특징
- 그래프는 네트워크 모델이다.
- 2개 이상의 경로가 가능하다.
- 즉, 노드들 사이에 무방향/방향에서 양방향 경로를 가질 수 있다.
- self-loop 뿐 아니라 loop/circuit 모두 가능하다.
- 루트 노드라는 개념이 없다.
- 부모-자식 관계라는 개념이 없다.
- 순회는 DFS나 BFS로 이루어진다.
- 그래프는 순환(Cyclic) 혹은 비순환(Acyclic)이다.
- 그래프는 크게 방향 그래프와 무방향 그래프가 있다.
- 간선의 유무는 그래프에 따라 다르다.

    ![그래프 종류](./img/[자료구조]graph_type.png)

- 참고) 오일러 경로(Eulerian tour)
	- 그래프에 존재하는 모든 간선(edge)을 한 번만 통과하면서 처음 정점(vertex)으로 되돌아오는 경로
	- 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재

### 그래프의 종류
- 무방향 그래프 (Undirected Graph)
	- 무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있음.
	- 정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현.
		- (A, B)는 (B, A) 동일
	- ex) 양방향 통행 도로

<br/>

- 방향 그래프 (Directed Graph)
	- 간선에 방향성이 존재하는 그래프
	- A -> B로만 갈 수 있는 간선은 <A, B>로 표시.
		- <A, B>는 <B, A>는 다름
	- ex) 일방 통행 도로

<br/>

- 가중치 그래프 (Weighted Graph)
	- 간선에 비용이나 가중치가 할당된 그래프
	- 네트워크(Network)라고도 함.
	- Ex) 도시-도시의 연결, 도로의 길이, 회로 소자의 용량, 통신망의 사용료 등

<br/>

- 연결 그래프 (Connected Graph)
	- 무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우
	- 그래프 G=(V, E) 내에 있는 **임의의 정점 u, v 간에 경로가 있는 그래프**
	- ex) 트리(Tree): 사이클을 가지지 않는 연결 그래프
	
<br/>

- 비연결 그래프 (Disconnected Graph)
	- 무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우

<br/>

- 사이클 (Cycle)
	- 단순 경로의 시작 정점과 종료 정점이 동일한 경우
	- 단순 경로(Simple Path) : 경로 중에서 반복되는 정점이 없는 경우

<br/>

- 비순환 그래프 (Acyclic Graph)
	- 사이클이 없는 그래프

<br/>

- 완전 그래프 (Complete Graph)
	- 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프
	- 그래프 G=(V, E) 내에 있는 **모든 정점 u, v 간에 변이 있는 그래프**
	- 무방향 완전 그래프 : 정점 수 n이면 간선의 수 n*(n-1)/2. 모든 꼭짓점은 차수 n-1을 가짐.
	- 방향 완전 그래프 : 정점 수 n이면 간선의 수 n*(n-1)  

### 자바에서 그래프를 인접행렬로 표현하는 법
- 인접 행렬은 2차원 배열로 그래프를 구현하는 방식.
- 인접행렬은 이차원 배열로 구현 가능. 행 개수 = 열 개수 = 정점의 수.<br/>
행이 출발정점, 열이 도착정점. 행렬의 모든 값을 0으로 초기화하고 시작.
- "정점 n과 m 연결되어있음" && "n에서 출발해 m 도착 가능" 하면 n행 m열의 값이 1(or 가중치값) 아니면 0으로 둠.
- 정점 n에서 출발해 도착할 수 있는 인접한 정점을 찾으려면 n행을 탐색하여
0 아닌 값이 저장된 열을 찾으면 됨.
- 반대로 정점 m에 도착할 수 있는 인접한 정점을 찾으려면 m열을 탐색하여 0 아닌 값이 저장된 행을 찾으면 됨.

```
1. 무방향 그래프 : 
간선의 방향이 정해져 있지 않아 양방향으로 진행 가능하므로, 정점 n과 m이 연결되어있다면 n행 m열과 m행 n열 두 곳에 1 저장.
ex) 정점 1과 정점 2가 연결되어있을 경우 => mat[1][2]=1, mat[2][1]=1 저장.

2. 방향 그래프 :
간선의 방향이 정해져 있어 한방향으로만 진행 가능하므로, 정점 n과 m이 연결되어있고 연결 방향이 n->m이라면 n행 m열에 1 저장.
ex) 정점 1과 정점 2가 1->2 방향으로 연결되어있을 경우 -> mat[1][2]=1 저장.
        
3. 가중치 무방향 그래프 :
간선의 방향이 정해져 있지 않아 양방향으로 진행 가능하며, 간선마다 가중치가 부과됨.정점 n과 m이 연결되어있고 가중치가 3이면 n행 m열과 m행 n열 두 곳에 가중치 값인 3 저장.
ex) 정점 1과 정점 2가 연결되어있으며 가중치 3일 경우 -> mat[1][2]=3, mat[2][1]=3 저장.
        
4. 가중치 방향 그래프 :
간선의 방향이 정해져 있으며, 간선마다 가중치가 부과됨. 정점 n과 m이 연결되어있고
연결 방향이 n->m이며 가중치가 3이면 n행 m열에 가중치 값인 3 저장.
ex) 정점 1과 정점 2가 1->2 방향으로 연결되어있으며 가중치 3일 경우 -> mat[1][2]=3 저장.
```

![인접행렬](./img/[자료구조]adj_matrix.png)

### 자바에서 그래프를 인접리스트로 표현하는 법
- 인접 리스트는 각 정점에 인접한 정점들을 리스트에 저장하여 그래프를 구현하는 방식.
- 인접리스트는 ArrayList<E> 객체를 저장할 수 있는 ArrayList(ArrayList<ArrayList<E>> graph)를 사용해 구현하며, ArrayList 객체(graph.get(x))에 정점 x에서 갈 수 있는 인접한 정점들을 리스트처럼 차례로 저장하는 방식으로 사용함.
- 인접행렬에서 각 행에 0이 아닌 값이 저장된 열 번호(=정점번호)들만 빼내서 이를 리스트처럼 각 행에 연결해놨다고 보면 됨. 
- 행 개수 = ArrayList 객체 개수 = 정점의 수이며, 열 개수 = 각 ArrayList 객체의 사이즈 = 각 정점에서 갈 수 있는 인접 정점들 개수.
- 그래프를 인접행렬 대신 인접리스트로 표현하면 탐색하는 데 걸리는 시간도 절약되고, 메모리도 절약됨. 그래서 문제풀 땐 보통 인접행렬 대신 인접리스트로 구현. (인접리스트가 인접행렬보다 더 빠름! 정점개수가 많아질 수록 인접행렬로 풀면 메모리 낭비도 되고 시간복잡도도 김. ex. 정점 10000개면 어떤 정점에서 갈 수 있는 정점 찾으려면 10000번 돌아야함.) 
- graph.get(x)는 ArrayList 객체를 리턴하므로 for-each문에 사용될 수 있음.
(ArrayList<ArrayList<Integer>> graph일 경우 for(int x : graph.get(x)){...})
	
```
ex1) 무방향 인접리스트의 경우,
정점 1이 1-2, 1-3 이렇게 연결되어있다고 하면,
graph.get(1).add(2);
graph.get(2).add(1);
graph.get(1).add(3);
graph.get(3).add(1);
//따라서 graph.get(1).get(0)=2, graph.get(2).get(0)=1, 
//graph.get(1).get(1)=3, graph.get(3).get(0)=1 이 됨.

ex2) 방향 인접리스트의 경우,
정점 1이 1->2, 1->3 이렇게 가능하다고 하면,
graph.get(1).add(2);
graph.get(1).add(3);
//따라서 graph.get(1).get(0)=2, graph.get(1).get(1)=3 이 됨.
	
가중치 그래프일 경우 인접리스트는 ArrayList<ArrayList<Edge>> graph 사용.
<Edge>는 변수 두개 포함하는 클래스 타입(ex. v, w 멤버변수 포함하는 Edge 클래스).
	
ex3) 무방향 가중치 인접리스트의 경우,
정점 1이 1-2 가중치 12라고 하면,	
graph.get(1).add(new Edge(2, 12));
graph.get(2).add(new Edge(1, 12));	
//따라서 graph.get(1).get(0).v=2, graph.get(1).get(0).w=12,
//graph.get(2).get(0).v=1, graph.get(2).get(0).w=12 가 됨.

ex4) 방향 가중치 인접리스트의 경우, 
정점 1이 1->2 가중치 12, 1->3 가중치 5이라고 하면,
graph.get(1).add(new Edge(2, 12));
graph.get(1).add(new Edge(3, 5));
//따라서 graph.get(1).get(0).v=2, graph.get(1).get(0).w=12,
//graph.get(1).get(1).v=3, graph.get(1).get(1).w=5 가 됨.

그래프가 문제에 등장할 경우 위 4가지 중 무엇인지 파악한 후 인접리스트 구현하기!
(1. 방향인지 무방향인지 2. 가중치인지 그냥인지) 
```
![인접리스트](./img/[자료구조]adj_list.png)

### 인접 행렬 VS 인접 리스트
- 인접 행렬
	- 그래프에 간선이 많이 존재하는 밀집 그래프(Dense Graph) 의 경우 선택
	- 장점
		- 두 정점을 연결하는 간선의 존재 여부 (M[i][j])를 O(1) 안에 즉시 알 수 있다.
		- 정점의 차수는 O(N) 안에 알 수 있다 : 인접 배열의 i번 째 행 또는 열을 모두 더한다.
	- 단점
		- 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다.
		- 그래프에 존재하는 모든 간선의 수는 O(N^2) 안에 알 수 있다. : 인접 행렬 전체를 조사한다.

<br/>

- 인접 리스트
	- 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(Sparse Graph) 의 경우 선택
	- 장점
		- 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다.
		- 그래프에 존재하는 모든 간선의 수는 O(V+E) 안에 알 수 있다 : 인접 리스트 전체를 조사한다.
	- 단점
		- 간선의 존재 여부와 정점의 차수: 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수만큼의 시간이 필요

### 그래프 관련 용어
- `연결(Incident)`: 정점과 간선 사이의 관계를 나타내는 용어로 간선이 정점에 연결되어 있다고 말함.
- `인접(Adjacent)`: 정점 사이의 관계를 나타내는 용어로 두 정점이 동일한 간선에 연결되어 있다면 두 정점이 인접해 있다고 말함.
- `유향 그래프(Directed Graph)`: 방향성이 있는 간선들로 이루어진 그래프
- `무향 그래프(Undirected Graph)`: 방향성이 없는 간선들로 이루어진 그래프
- `가중치 그래프(Weighted Graph)`: 그래프를 구성하는 간선에 가중치가 존재하는 그래프
- `정점의 차수(Degree)`: 무향 그래프에서 정점 V와 인접한 정점의 수를 정점 V 의 차수라고 함.
- `진입 차수(In-Degree)`: 유향 그래프에서 다른 정점에서 정점 V 로 향하는 방향을 가진 간선의 수를 정점 V 의 진입 차수라고 함.
- `진출 차수(Out-Degree)`: 유향 그래프에서 정점 V 에서 다른 정점으로 향하는 방향을 가진 간선의 수를 정점 V 의 진출 차수라고 함.
- `경로(Path)`: 한 정점에서 다른 한 정점으로 향하는 연속된 간선들의 Sequence를 말함. Path 중에서 한 번 방문한 정점은 다시 방문하지 않는 경로(경로 중에서 반복되는 정점이 없는 경우)를 `Simple Path`라고 함.
- `도달 가능(Reachable)`: 정점 V에서 정점 W로의 경로가 존재하는 경우 정점 W는 정점 V에서 도달 가능하다라고 함.
- `Connected Graph`: 모든 정점 사이의 경로가 존재하는 그래프를 말함. 유향 그래프에서 모든 정점 사이의 경로가 존재하는 그래프는 특별히 `Strongly Connected Graph`라고 함.
- `Cycle`: 출발 정점과 도착 정점이 같은 경로를 Cycle이라고 함. Cycle이 없는 그래프는 `Acyclic Graph`.

### 그래프의 공간복잡도
- V(Vertex) : 그래프 안에 있는 모든 노드들의 집합을 V라고 함.
- E(Edge) : 그래프 안에 있는 모든 에지들의 집합을 E라고 함.
- 인접 행렬의 공간복잡도 : 인접 행렬을 정의할 때 V * V 만큼의 행렬을 만들어 사용하므로, 인접 행렬이 차지하는 공간은 **O(V^2)**
- 인접 리스트의 공간복잡도 : 노드 수와 에지의 개수 중 어떤 것이 큰 지 알 수 없기에 **O(V+E)** 만큼의 공간을 사용한다고 표현

### 그래프의 시간복잡도
시간복잡도는 크게 2가지로 나뉨.<br/>

(1) 두 노드가 연결되었는지 확인하는데 걸리는 시간 <br/>
- 인접 행렬의 경우, 고유 인덱스 값으로 행렬에 접근하여 **O(1)**
- 인접 리스트의 경우, 노드의 수가 V라 할 때 최악의 경우 총 V개의 요소를 확인해야 하므로 **O(V)**
<br/>

(2) 한 노드에 연결된 모든 노드들을 확인하는데 걸리는 시간
- 인접 행렬의 경우, 연결된 모든 노드를 확인하기 위해선 매번 V번 돌아야 하므로 **O(V)**
- 인접 리스트의 경우, 특정 노드의 인접 리스트에 접근하면 특정 노드와 인접 관계에 있는 노드들의 레퍼런스를 알 수 있으며 엣지의 개수만큼 확인하면 되므로 **O(E)**

### 결론
그래프의 공간복잡도
- 인접 행렬 : O(V^2)
- 인접 리스트 : O(V+E)

그래프의 시간복잡도<br/>
(1) 두 노드가 연결되었는지 확인하는데 걸리는 시간
- 인접 행렬 : O(1)
- 인접 리스트 : O(V)

(2) 한 노드에 연결된 모든 노드들을 확인하는데 걸리는 시간
- 인접 행렬 : O(V)
- 인접 리스트 : O(E)

사실상 그래프 알고리즘 문제에서 가장 중요한 것은 특정 노드에 연결된 모든 노드를 찾는 것.<br/>
따라서 공간도 적게 사용하면서 위 경우 탐색 시간도 빠른 인접 리스트가 훨씬 많이 사용된다.

## 그래프의 탐색
그래프의 탐색 방법은 깊이 우선 탐색(Depth First Search)과 너비 우선 탐색(Breadth First Search)이 있음.

### DFS (Depht First Search)
시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사.<br/>
루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

- 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것
- 사용하는 경우: 모든 노드를 방문 하고자 하는 경우에 이 방법을 선택
	
+) 이진트리를 깊이 우선 탐색할 경우, 순회방법에는 전위순회, 중위순회, 후위순회가 있음.
각 방법은 루트와 왼쪽 서브트리, 오른쪽 서브트리 중에서 루트를 언제 방문하느냐에 따라 구분됨(루트를 서브 트리에 앞서서 먼저 방문(출력)하면 전위순회, 루트를 왼쪽과 오른쪽 서브트리 중간에 방문하면 중위순회, 루트를 서브트리 방문 후에 방문하면 후위순회가 됨).
	
재귀함수로 dfs 구현하려면, if else문을 사용하여 if에 종료조건 구현하고
else에 자식노드 호출 과정 관련하여 구현하면 됨.
```java
(재귀함수로 구현한 이진트리 DFS 코드 예시)
public void dfs(Node root){ //처음엔 시작노드로 호출. ex) dfs(1);
    if(root==null) return; //종료조건.
    else{
        //System.out.print(root.data+" "); //여기 두면 전위순회(=왼쪽 자식노드 방문 전에 실행할 코드).
        dfs(root.lt); //왼쪽 자식노드 호출.
        //System.out.print(root.data+" "); //여기 두면 중위순회(=왼쪽 끝나고 부모노드로 돌아와서 오른쪽 자식노드 방문 전에 실행할 코드).
        dfs(root.rt); //오른쪽 자식노드 호출.
		  //System.out.print(root.data+" "); //여기 두면 후위순회(=자식노드 모두 방문한 후에 실행할 코드).
	}
}
```
```java
(재귀함수로 구현한 이진트리 DFS 코드 예시 - 트리 레벨 이용)
public void dfs(int lev, ...){
	if(/*lev==(마지막레벨)*/) return; //종료조건.
	else{
		//...; //여기 두면 전위순회(=왼쪽 자식노드 방문 전에 실행할 코드).
		dfs(lev+1, ...); //왼쪽 자식노드 호출.
		//...; //여기 두면 중위순회(=왼쪽 끝나고 부모노드로 돌아와서 오른쪽 자식노드 방문 전에 실행할 코드).
		dfs(lev+1, ...); //오른쪽 자식노드 호출.
		//...; //여기 두면 후위순회(=자식노드 모두 방문한 후에 실행할 코드).
	}
}
```

위의 코드를 응용하여 n진트리 DFS도 구현 가능함. 또한 dfs를 진행하면서 이와 동시에 어떤 계산이 이루어지는 상황이라면 노드와 함께 값을 추가로 매개변수로 넘겨줘도 됨. 

```java
(재귀함수로 구현한 n진트리 DFS 코드 예시 - 레벨과 값을 같이 넘겨줄 경우)
public void D(int l, int x){ //처음엔 시작노드와 초기상태의 값으로 호출. ex) D(1, 0);
	if(/*l==(마지막레벨)*/) return; //종료조건.
	else{
		//...; //첫번째 자식노드 방문 전에 실행할 코드.
		D(l+1, f1(x)); //첫번째 자식노드 호출, 첫번째 자식노드 호출할때 가져갈 값을 같이 넘겨줌.
		//...; //첫번째 끝나고 부모노드로 돌아와서 두번째 자식노드 방문 전에 실행할 코드.
		D(l+1, f2(x)); //두번째 자식노드 호출, 두번째 자식노드 호출할때 가져갈 값을 같이 넘겨줌.
		...
		//...; //n-1번째 끝나고 부모노드로 돌아와서 n번째 자식노드 방문 전에 실행할 코드.
		D(l+1, fn(x)); //n번째 자식노드 호출, n번째 자식노드 호출할때 가져갈 값을 같이 넘겨줌.
		//...; //자식노드 모두 방문한 후에 실행할 코드.
	}
}
```
<br/>

+) DFS 문제 예시 :
- 부분집합 구하기 :<br/>
해당 원소를 포함(선택 O) / 해당 원소를 포함하지 않음(선택 x) 의 2가지 가지를 쳐가며 이진트리 만듦.한 레벨 늘리면서 한 원소를 선택할지 여부를 결정하기 때문에 총 n개 중에 선택한다고 했을 때 lev=0에서 시작하면 lev==n일 때가 종료조건이 됨.
	
- 중복순열 구하기(각 경우 출력) :<br/>
		서로 다른 n개의 원소 중에서 중복을 허용하여 m개를 뽑아서 일렬로 나열하는 경우의 수를
		구한다고 할 때, n개씩 m번 가지치면 됨. 한 레벨 늘리면서 숫자 한 개 뽑으므로,
		lev=0에서 시작하면 lev==m일 때가 종료조건이 됨.
		
- 순열(중복x) 구하기(각 경우 출력) :<br/>
		서로 다른 n개의 원소에서 m개를 중복없이 뽑아서 일렬로 나열하는 경우의 수를 구한다고 할 때,
		n개씩 m번 가지치되 chk배열로 이미 뽑은 수(중복)를 거르고 가지쳐주면 됨.
		(순열은 5P3= 5X4X3. 앞에서 뽑은 한개를 제외하고 뽑고를 반복하는 형식.)
		한 레벨 늘리면서 숫자 한 개 뽑으므로, lev=0에서 시작하면 lev==m일 때가 종료조건이 됨.

- 조합 구하기(각 경우 출력) :<br/>
		서로 다른 n개의 원소에서 순서에 상관없이 r개의 원소를 뽑는 경우의 수를 구한다고 할 때,
		매번 start를 앞 레벨에 뽑았던 수의 바로 뒷차례 수로 초기화하고, start부터 n까지
		(앞에서 뽑았던 수의 뒷차순 수들)중에 하나 뽑아 가지치는 것을 m번 반복하면 됨.
		한 레벨 늘리면서 숫자 한 개 뽑으므로, lev=0에서 시작하면 lev==m일 때가 종료조건이 됨.
	
    ```java
    public void dfs(int lev, int start){
        if(lev==m){
            for(int x : answer) System.out.print(x+" ");
            System.out.println();
        }
        else{
            for(int i=start; i<=n; i++){
                answer[lev]=i;
                dfs(lev+1, i+1); //앞에서 뽑은 수(i)의 뒷차순 수 중에서만 뽑도록 start에 i+1 대입
            }
        }
    }
    ```

 	+) 정해진 적은 개수를 뽑는 조합은 for문으로도 구할 수 있음. ex) nC3
    ```java
	for(int i=0; i<nums.length; i++){
        for(int j=i+1; j<nums.length; j++){
            for(int k=j+1; k<nums.length; k++){
                // nums[i], nums[j], nums[k]가 고른 3가지 수. 
            }
        }
    }
    ```
	+) 비트연산으로도 조합 쉽게 구할 수 있음.

- nCr = ? 값구하기 (출력 x. 조합 결과값만 구하기) :<br/>
		nCr = n-1Cr-1 + n-1Cr 공식 이용.
		nCr일 때 n명 중 한 명을 선택해 걔의 관점에서 뽑음.
		5C3 = 4C2 + 4C3 (걔를 포함해 셋을 뽑을 때 + 걔를 제외하고 셋을 뽑을 때)
		3C1 = 3C0 + 3C1 (걔를 포함해 한명을 뽑을 때 + 걔를 제외하고 한명을 뽑을 떄)
		이를 이용하여 이항계수(nCr)을 DFS로 구할 수 있음.
		3C3, 3C0처럼 n=r 이거나 r=0일 때는 무조건 값이 1이므로 이 때 return 1 해주면 됨.
		추가로 메모이제이션 사용하여 실행시간을 줄임.
		
    ```java
	public int dfs(int n, int r){
        if(memo[n][r]>0) return memo[n][r]; //메모이제이션
        if(n==r || r==0) return 1;
        else return memo[n][r]=dfs(n-1, r-1)+dfs(n-1, r);
    }
    ```

### BFS(Breadth First Search)
시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방범.<br/> 

- 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것
- 사용하는 경우 : 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택

가까운 거리에 있는 정점들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(queue)가 필요함. 알고리즘은 무조건 큐에서 정점을 꺼내서 정점을 방문하고 인접정점들을 큐에 추가함. 큐가 소진될때까지 동일한 코드를 반복함.<br/>

**"어떤 출발점에서 도착점으로 가는데, 최단 거리로(or 최소로 걸려서) 가라"고 하면, 무조건 BFS(큐) 문제.** BFS는 레벨탐색이라서, 한번만에 갈 수 있는 곳 다 탐색하고, 
그 한번만에 갈 수 있는 곳들을 통해서 두번만에 갈 수 있는 곳 다 탐색하고, ... 이렇게 퍼져나가면서 원하는 결과로 가기까지 최소 몇번의 레벨이 필요한지를 구할 수 있음.

```java
(Node 클래스 이용한 BFS 구현 예시 - lev 변수 사용)	
public void bfs(Node root){
    Queue<Node> Q = new LinkedList<>();
		Q.offer(root); //루트노드 삽입
		int L=0; //레벨 저장해두는 변수
		while(!Q.isEmpty()){ //큐가 비어있을 때까지 반복
				int len = Q.size();
				//System.out.print(L+" : ");
				for(int i=0; i<len; i++){
				  Node cur = Q.poll(); //큐에서 정점 꺼냄
				  //System.out.print(cur.data+" ");
				  if(cur.lt!=null) Q.offer(cur.lt); //자식노드 큐에 집어넣음
				  if(cur.rt!=null) Q.offer(cur.rt);
				}
				L++;
				//System.out.println();
	    }
}
// 아래와 같이 출력됨.
// 0 : 1 
// 1 : 2 3 
// 2 : 4 5 6 7
```

+) 레벨 저장해두는 변수로 배열이나 이차원 배열을 사용하고, '큐에서 뽑은 정점의 최단거리+1'을 다음 레벨 정점들의 최단거리로 저장(dis[nv] = dis[v]+1)할 수도 있음.<br/>
이 방법으로 풀 경우, while문 매번 돌 때마다 큐 사이즈 재서 for문을 돌려줄 필요가 없어져서 while문만 돌려주면서 큐에서 정점꺼내 할 일 하면 됨.
```java
(Node 클래스 이용한 BFS 구현 예시 - distance 배열 사용)
public void bfs(){
    Queue<Integer> q = new LinkedList<>();
    chk[1]=1;
    q.offer(1);
    while(!q.isEmpty()){
        int cur = q.poll();
        for(int x : graph.get(cur)){
            if(chk[x]==0){
                chk[x]=1;
                dis[x]=dis[cur]+1;
                q.offer(x);
            }
        }
    }
}
```

+) 만약 노드 중 중복되는 노드가 존재하며 해당 노드 방문할 필요 없을 경우, chk 배열 사용하여 중복되는 노드가 아닐 경우에만 큐에 넣도록 추가 구현해 실행시간 줄일 수 있음. chk 배열 사용 시 dfs는 내려갔다가 다시 올라와야 하므로 체크해뒀던 것을 다시 풀어주는 (chk[x]=1; -> dfs -> chk[x]=0;) 과정이 필요하지만, bfs는 레벨순대로 쭉 내려가기만 하므로 내려가면서 쭉 체크만 하고 체크해뒀던 것을 다시 풀어줄 필요가 없음.

+) BFS 응용문제 :
- 하나의 시작 노드에서부터 시작해 레벨순회해나가는 BFS(기본).
- 여러개의 시작노드가 있는 레벨층에서 시작해 레벨순회해나가는 BFS. (ex. 토마토)
- 하나의 시작노드에서부터 시작해 레벨순회해나가며 특정 노드를 찾고, 찾으면 시작노드를 바꿔서 처음부터 다시 레벨순회해나가는 것을 반복하는 BFS. (ex. 라이언킹 심바)
...

### 시간복잡도
DFS와 BFS 모두 인접 리스트로 구현한 경우엔 O(V + E) 시간복잡도를 갖고<br/> 인접 행렬로 구현한 경우엔 O(V^2) 시간복잡도를 가짐.